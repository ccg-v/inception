1. `docker compose up --build -d`
to build images and start containers. Everything went apparently fine.
2. `curl localhost:9000`
3. Error: _curl: (7) Failed to connect to localhost port 9000: Connection refused_
---
## Test:
<u>`curl -k https://localhost`</u>

Output is:

		<html>
		<head><title>403 Forbidden</title></head>
		<body>
		<center><h1>403 Forbidden</h1></center>
		<hr><center>nginx/1.18.0</center>
		</body>
		</html>

This means:
- Nginx is running properly
- TLS is working (the `-k` flag skips the certificate check)
- But **Nginx couldn’t serve the requested file**

In short: **Nginx got the request, but had nothing to serve back**.

### Debugging:

```bash
$> docker exec -it nginx ls -l /var/www/html/
total 4
-rw-r--r--  1 root root 612 May  1 00:39 index.nginx-debian.html
```

Wordpress files (`index.php`, `wp-config.ph`, `wp-login.php`...) are not in the volume shared by nginx and wordpress... \
Maybe we are not really sharing a single volume and each service has its own one? \
Let's look at wordpress volume's content: 

```bash
$> docker exec -it wordpress ls -l /var/www/html/
total 4
-rw-r--r--  1 root root 612 May  1 00:39 index.nginx-debian.html
```

It is also empty, which suggests that the volume is hiding the files. Here's the catch:
> [!IMPORTANT]
> When you mount a volume on a path like `/var/www/html`, any files added before the volume is mounted are hidden (not really overwriting but shadowing them).

So if WordPress writes files before the volume is mounted, the volume will later mount over them and hides the WordPress files.

In my wordpress/Dockerfile, I currently do:
```Dockerfile
# Download WordPress
RUN mkdir -p /var/www/html \
	&& curl -O https://wordpress.org/latest.tar.gz \
	&& tar -xzf latest.tar.gz \
	&& mv wordpress/* /var/www/html/ \
	&& rm latest.tar.gz \
	&& rm -rf wordpress
```
But <u>**that happens during image build, that is, before volumes exist!**</u>
So when Docker mounts `wordpress_data:/var/www/html`, it creates an empty volume and hides what the image placed there.

### Fixing: 

Move the WordPress installation from Dockerfile RUN to script `setup.sh`, and run it when the container starts, not when it's built.

``` sh
# tools/setup.sh
mkdir -p /var/www/html
curl -O https://wordpress.org/latest.tar.gz
tar -xzf latest.tar.gz
mv wordpress/* /var/www/html/
rm -rf wordpress latest.tar.gz
```

Now, if we look inside `/var/www/html` in wordpress and nginx containers, WordPress files should be there.

---

## Test:
<u>`curl -k https://localhost`</u>

Output is:

		<html>
		<head><title>504 Gateway Time-out</title></head>
		<body>
		<center><h1>504 Gateway Time-out</h1></center>
		<hr><center>nginx/1.18.0</center>
		</body>
		</html>

A _504 Gateway Time-out_ from NGINX means that NGINX successfully received our request, but it couldn't get a response from the backend (in our case, PHP-FPM inside the WordPress container) within the allowed time.

### Debugging

1. Check that PHP-FPM is running inside the WordPress container:
	``` bash
		$> docker exec -it wordpress ps aux | grep php-fpm
		root            1 0.0  0.5   194088   21100  ?          Ss      19:30     0:00  php-fpm:  mast
		www-data       19 0.0  0.1   194088    7392  ?          S       19:30     0:00  php-fpm:  pool
		www-data       20 0.0  0.1   194088    7392  ?          S       19:30     0:00  php-fpm:  pool
	```
	The output should display the master and worker processes as below

2. Check in the Nginx config file that `fastcgi_pass` is pointing to the correct container name and port
	```nginx
		# nginx.conf
		location ~ \.php$ {
			include fastcgi_params;
			fastcgi_pass wordpress:9000;
			...
		}
	```
3. Run from the Nginx container:
	```bash
		docker exec -it nginx apt-get update && apt-get install -y curl
		curl wordpress:9000
	```
	If it fails, it's likely a networking or service resolution issue.

	`curl: (28) Failed to connect to wordpress port 9000: Connection timed out`

	That means **Nginx cannot reach PHP-FPM** at all. The PHP-FPM process **inside the WordPress container is not listening on TCP port 9000**. Most likely, it’s configured to use a Unix socket instead. So when NGINX tries to connect to `wordpress:9000`, there's nothing listening, and it times out → 504 error.
	This happens because Debian-based systems default PHP-FPM to listen on Unix sockets for performance. But when containers need to communicate across the network (like WordPress and NGINX), TCP (e.g. port 9000) is more straightforward.

### Fixing

By default, PHP-FPM is set in `www.conf` to listen on a Unix socket:

`listen = /run/php/php7.4-fpm.sock`

We need to override the `/etc/php/*/fpm/pool.d/www.conf` file that is generated by default with our own file with custom values:


	[www]

	; Run as www-data (default user in most PHP images)
	user = www-data
	group = www-data

	; Accept FastCGI requests via TCP (not socket)
	listen = 0.0.0.0:9000

	; Basic process management (default values)
	pm = dynamic
	pm.max_children = 5
	pm.start_servers = 2
	pm.min_spare_servers = 1
	pm.max_spare_servers = 3

- `user` and `group`: Ensures processes run with correct permissions.
- `listen`: Enables TCP communication with Nginx (`wordpress:9000`).
- `pm` section: Required by PHP-FPM to manage worker processes. You can’t omit it entirely, even if you don’t tweak the values.





